scriptencoding utf-8

" ------------------------------------------------------------------------------
" Support functions for keymaps
" ------------------------------------------------------------------------------
function! s:ToggleHLS() abort
    " Toggling the highlight on a search result is a little funky. We want to hide the highlight
    " without disabling the hlsearch option. If we simply toggled hlsearch then we would have to
    " remember to turn it back on anytime we did a search.
    if &hlsearch && v:hlsearch
        echo 'nohls'
        return ':nohls'
    else
        echo 'hls'
        return ':set hls'
    endif
endfunction
command! HLSToggle call s:ToggleHLS()

function! s:LListClose() abort
    " Location list can't be closed if there's cursor in it, so we need to call lclose twice to
    " move cursor to the main pane
    if IsQFLLFocused() == 1
        silent! lclose
    endif
    silent! lclose
endfunction
command! LLClose call s:LListClose()

function! s:LListToggle() abort
    let l:buffer_count_before = s:BufferCount()

    call s:LListClose()

    if s:BufferCount() == l:buffer_count_before
        silent! lopen
    endif
endfunction
command! LToggle call s:LListToggle()

function! s:QListClose() abort
    silent! cclose
endfunction
command! QLClose call s:QListClose()

function! s:QListToggle() abort
    let l:buffer_count_before = s:BufferCount()
    let l:working_tab = tabpagenr()
    call s:QListClose()

    execute 'tabnext' l:working_tab
    if s:BufferCount() == l:buffer_count_before
        silent! botright copen
    endif
endfunction
command! QToggle call s:QListToggle()

function! s:_IsQFLLFocused()
    silent! exec 'redir @a | ls | redir END'
    if match(@a,'%a-  "\[Location List\]"') >= 0
        return 1
    elseif match(@a,'%a-  "\[Quickfix List\]"') >= 0
        return 2
    else
        return 0
    endif
endfunction
command! IsQFLLFocused call s:_IsQFLLFocused()

function! s:BufferCount() abort
    return len(filter(range(1, bufnr('$')), 'buflisted(v:val)'))
endfunction

function! s:CloseWindows() abort
    " A general clear-the-clutter function to close windows we have mapped
    if IsQFLLFocused() == 1
        LLClose
    endif
    if IsQFLLFocused() == 2
        QLClose
    endif
    let l:working_buffer = bufnr('%')
    silent! QLClose
    silent! bufdo LLClose
    silent! helpclose
    silent! GundoHide
    silent! TagbarClose
    execute 'buffer' l:working_buffer
endfunction
command! CloseMyWindows call s:CloseWindows()


" ------------------------------------------------------------------------------
" leader maps for running common actions
" ------------------------------------------------------------------------------

" change leader to space, nicer to type. You lose some sort of 'move to next char' command.
let g:mapleader = "\<Space>"

nnoremap <silent> <Leader>a :FSHere<cr>

" toggle spelling quickly
nnoremap <silent> <leader>os :set spell! spell?<CR>

" toggle highlight quickly
nnoremap <silent> <expr><Leader>oh :HLSToggle<CR>

" flip between light and dark background
nnoremap <silent> <leader>ob :set background=<C-R>=&background == "dark" ? "light" : "dark"<CR><CR>

" toggle line numbers
nnoremap <silent> <leader>on :set number! number?<CR>

" toggle relative number
nnoremap <silent> <leader>or :set relativenumber! relativenumber?<CR>

" remap bufexplorer
nnoremap <silent> <leader>be :BufExplorer<CR>
nnoremap <silent> <leader>bt :ToggleBufExplorer<CR>
nnoremap <silent> <leader>bs :BufExplorerHorizontalSplit<CR>
nnoremap <silent> <leader>bv :BufExplorerVerticalSplit<CR>

" open and close various windows
nnoremap <silent> <leader>Wt :TagbarToggle<CR>
nnoremap <silent> <leader>Wg :GundoToggle<CR>
nnoremap <silent> <leader>Wq :QToggle<CR>
nnoremap <silent> <leader>Wl :LToggle<CR>
nnoremap <silent> <leader>Wc :CloseMyWindows<CR>

" run diagnostics if available
noremap <leader>d :LspDocumentDiagnostics<CR>

" navigate through quickfix and locationlists
nnoremap <silent> <leader>q :cnext<CR>
nnoremap <silent> <leader>Q :cprevious<CR>

nnoremap <silent> <leader>l :lnext<CR>
nnoremap <silent> <leader>L :lprevious<CR>

" use leader {y|d|p} for interacting with the system clipboard
vnoremap <Leader>y "+y
nnoremap <Leader>p "+p
nnoremap <Leader>P "+P
vnoremap <Leader>p "+p
vnoremap <Leader>P "+P

" run make silently and open the quickfix window in case of errors
nnoremap <leader>m :silent make\|redraw!\|cc<CR>

" Insert date on f12
nnoremap <F12> "=strftime("%c")<CR>P

" Spell check the last error.
" <ctrl-g>u     create undo marker (before fix) so we can undo/redo this
"               change. Otherwise vim treats the spelling correction as the
"               same change as our edit.
" esc           enter normal mode
" [s            jump back to previous spelling mistake
" 1z=           take the first correction
" `]            jump back
" a             continue editing
" <ctrl-g>u     create another undo marker
inoremap <C-l> <c-g>u<Esc>[s1z=`]a<c-g>u

" ------------------------------------------------------------------------------
" Keymaps that alter default behavior.
" ------------------------------------------------------------------------------

" Advance to next misspelling after adding a word to the spellfile.
noremap zg zg]s

" typing jj in insert mode gets you out.
inoremap jj <Esc>

" vim training wheels: dont allow arrow keys!
nnoremap <up> <nop>
nnoremap <down> <nop>
nnoremap <left> <nop>
nnoremap <right> <nop>

" fix direction keys for line wrap, other wise they jump over wrapped lines
nnoremap j gj
nnoremap k gk

"remap f1. I'll type :help when I want it
noremap <F1> <ESC>
inoremap <F1> <ESC>

"keep cursor in the middle of the screen while keyscrolling
"nnoremap <C-d> <C-d>zz
"nnoremap <C-u> <C-u>zz

"move between windows a little easier
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" I have never intentionally entered the mode that q: gives.
noremap q: :q
nnoremap Q <nop>

"Make up/down/cr map to the (oddly) more useful ctrl-n, ctrl-p, ctrl-y, ctrl-e
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
inoremap <expr> <Down>     pumvisible() ? "\<C-n>" : "\<Down>"
inoremap <expr> <Up>       pumvisible() ? "\<C-p>" : "\<Up>"

vmap v <Plug>(expand_region_expand)
vmap <S-v> <Plug>(expand_region_shrink)

" Indent in visual and select mode automatically re-selects.
vnoremap > >gv
vnoremap < <gv

nmap <silent><unique> <leader>w1 :WikiDown 'notes'<CR>
nmap <silent><unique> <leader>w2 :WikiDown 'adamatom'<CR>
nmap <silent><unique> <leader>w3 :WikiDown 'home'<CR>
nmap <silent><unique> <leader>w4 :WikiDown 'gen6'<CR>

" ------------------------------------------------------------------------------
" command mode replacements
" ------------------------------------------------------------------------------

" :wq when I meant :w. Nudges towards using :x
cabbrev wq w

" :W isnt a command, and I usually intend on :w
cabbrev W w

" :X is a strange crypto thing that I dont care about, intention is :x
cabbrev X x

" :Q enters modal ex mode, I'm happy with just ex command line. Generally mistyped :q
cabbrev Q q

" Similar to above, I generally mean :qa
cabbrev Qa qa

" Tabnew -> tabnew
cabbrev Tabnew tabnew

" Allow saving of files as sudo when I forgot to start vim using sudo.
cabbrev w!! w !sudo tee > /dev/null % <bar> edit!
